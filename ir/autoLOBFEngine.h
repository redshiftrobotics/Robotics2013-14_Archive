#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     IR,             sensorI2CCustom)
#pragma config(Motor,  mtr_S1_C1_1,     left_front,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     left_back,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_1,     right_front,   tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     right_back,    tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "HitecnicInfaredLibrary.h"

/*
	Motor 1 Daisychain 1 on S1 is left front
	Motor 2 Daisychain 1 on S1 is left back
	Motor 1 Daisychain 2 on S1 is right front
	Motor 2 Daisychain 2 on S1 is right back
*/

/*This code is to read the IRSeekerV2 signal and beep when the seeker is pointing directly at the IRBeacon. Currently the code only outputs the y-intercept and slope for the Line of Best Fit (LOBF); read below for more specifics. This code needs to be calibrated before it works: read through the specifics and then consult the bottom of the header.

- Program Specifics
The IRSeekerV2 data is being filtered with a method called "Line of Best Fit" or "Least-Squares Method" which I followed from the following URL: http://hotmath.com/hotmath_help/topics/line-of-best-fit.html.

- Inputs
Each LOBF calculation uses 10 x-inputs and 10 y-inputs. Each X-input is a reading from the IR "acs3" stored in the array "irInput". Assuming the time interval between readings is constant when we constanly call the "HTIRS2readALLACStrencth" function, each corrosponding y-input is an arbirary number 1-10 to remove the equations reliance on actual time.

-Calculation Uses
Isaac, AJ, Dale, and I recognized a nice bell-curve shape when strenght over time from the IR "acs3" signal is graphed. Using the LOBF formula found on the aformentioned URL, we calculate slope. This slope, should approach a value of zero, if not be at zero, only at the top of the bell curve when the IRSeekerV2 is pointing at the IRBeacon. The calculated y-intercept can serve as a threshold for the IR signal however, notice it is dependant on the distance between the IRBeacon and IRSeekerV2
*/

int acS1, acS2, acS3, acS4, acS5 = 0;
int n = 10; //Change sample size

long sY = 0; //We are squaring summations -> KEEP THESE AS LONGS
long sX = 0;
long spX2p = 0;
long psXp2 = 0;
float mpsXp2 = 0;
long sXsY = 0;
float msXsY = 0;
long spXYp = 0;

float slopeLOBF = 0;

task main()
{
	clearDebugStream();

	const int encoderCountAtBeginning = nMotorEncoder[left_back];

	motor[left_back] = 25;
	motor[left_front] = 25;
	motor[right_back] = -25;
	motor[right_front] = -25;

	while(true)
	{
		sY = 0;
		sX = 0;
		spXYp = 0;
		spX2p = 0;
		for (int X = 1; X<n+1 ; X++)
		{

			HTIRS2readAllACStrength(IR, acS1, acS2, acS3, acS4, acS5);
			sY += acS3;
			sX += X;
			spX2p += X*X;
			spXYp += (X * acS3) ;
			writeDebugStream("%i,", acS3);
			writeDebugStreamLine("0");
			Sleep(10);
		}
		psXp2 = (sX*sX);
		mpsXp2 = psXp2/n;
		sXsY = (sX*sY);
		msXsY = (sXsY)/n;
		slopeLOBF = (spXYp - msXsY)/(spX2p - mpsXp2);

		if (slopeLOBF < 0) //the denominator can be the threshold turn point. Notice it is dependant on speed of robot and rotation of sensor.
		{
			PlayTone(1000,13);

			writeDebugStreamLine("encoder: %i", nMotorEncoder[left_back]);
			writeDebugStreamLine("encoders moved forward: %i", nMotorEncoder[left_back]- encoderCountAtBeginning);

			int currentEncoderValue = nMotorEncoder[left_back];
			while (nMotorEncoder[left_back] < currentEncoderValue-(1440*0.1))
			{
				writeDebugStream("backing up");
				motor[left_back] = 25;
				motor[left_front] = 25;
				motor[right_back] = -25;
				motor[right_front] = -25;
				Sleep(10);
			}

			// turn right 90 deg.
			if (turnAtIrBeacon) {
				int i = nMotorEncoder[left_back];
				while (nMotorEncoder[left_back] > i-(1440*0.6))
				{
					writeDebugStreamLine("comparing %i > %i", nMotorEncoder[left_back], i+(1440*0.6));
					motor[left_back] = -25;
					motor[left_front] = -25;
					motor[right_back] = -25;
					motor[right_front] = -25;
					Sleep(10);
				}
			}

			writeDebugStreamLine("turning left");

			// complete stop
			motor[left_back] = 0;
			motor[left_front] = 0;
			motor[right_back] = 0;
			motor[right_front] = 0;

			Sleep(500);

			writeDebugStreamLine("i've been sleeping yo");

			// turn left 90 deg.
			if (turnAtIrBeacon) {
				int i = nMotorEncoder[left_back];
				writeDebugStreamLine("%i", i);
				while (nMotorEncoder[left_back] < i+(1440*0.95))
				{
					writeDebugStreamLine("comparing %i < %i", nMotorEncoder[left_back], i+(1440*0.95));
					motor[left_back] = 25;
					motor[left_front] = 25;
					motor[right_back] = 25;
					motor[right_front] = 25;
					Sleep(10);
				}
			}

			writeDebugStreamLine("i've reached the turn point.");

			// move forward until the end
			currentEncoderValue = nMotorEncoder[left_back];
			writeDebugStreamLine("%i", currentEncoderValue);
			while (nMotorEncoder[left_back] < encoderCountAtBeginning+6400)
			{
				writeDebugStreamLine("comparing %i < %i", nMotorEncoder[left_back], encoderCountAtBeginning-6600);
				motor[left_back] = 25;
				motor[left_front] = 25;
				motor[right_back] = -25;
				motor[right_front] = -25;
				Sleep(10);
			}

			// reset the motors
			nMotorEncoder[left_back] = 0;
			//const int referenceEncoderValue = nMotorEncoder[left_back];

			// turn right 45 deg.
			if (turnAtIrBeacon) {
				int i = nMotorEncoder[left_back];
				while (nMotorEncoder[left_back] > i-(1440*0.3))
				{
					writeDebugStreamLine("comparing %i > %i", nMotorEncoder[left_back], i+(1440*0.6));
					motor[left_back] = -25;
					motor[left_front] = -25;
					motor[right_back] = -25;
					motor[right_front] = -25;
					Sleep(10);
				}
			}

			// go forward for a little while
			if (turnAtIrBeacon) {
				int i = nMotorEncoder[left_back];
				while (nMotorEncoder[left_back] < i+2850)
				{
					writeDebugStreamLine("comparing %i < %i", nMotorEncoder[left_back], i+4000);
					motor[left_back] = 25;
					motor[left_front] = 25;
					motor[right_back] = -25;
					motor[right_front] = -25;
					Sleep(10);
				}
			}

			// turn right 90 deg.
			if (turnAtIrBeacon) {
				int i = nMotorEncoder[left_back];
				while (nMotorEncoder[left_back] > i-(1440*0.6))
				{
					writeDebugStreamLine("comparing %i > %i", nMotorEncoder[left_back], i-(1440*0.6));
					motor[left_back] = -25;
					motor[left_front] = -25;
					motor[right_back] = -25;
					motor[right_front] = -25;
					Sleep(10);
				}
			}

			// go forward for a little while
			if (turnAtIrBeacon) {
				int i = nMotorEncoder[left_back];
				while (nMotorEncoder[left_back] < i+5000)
				{
					writeDebugStreamLine("comparing %i < %i", nMotorEncoder[left_back], i+20000);
					motor[left_back] = 25;
					motor[left_front] = 25;
					motor[right_back] = -25;
					motor[right_front] = -25;
					Sleep(10);
				}
			}



			motor[left_back] = 0;
			motor[left_front] = 0;
			motor[right_back] = 0;
			motor[right_front] = 0;

			break;
		}
		writeDebugStream("0, ");
		writeDebugStream("slope:%f, ", slopeLOBF);
		writeDebugStream("sY:%i, ", sY);
		writeDebugStream("psXp2:%i, ", psXp2);
		writeDebugStream("mpsXp2:%f, ", mpsXp2);
		writeDebugStream("sXsY:%i, ", sXsY);
		writeDebugStream("msXsY:%f, ", msXsY);
		writeDebugStreamLine("spXYp:%i", spXYp);
		Sleep(50);
	}
}
