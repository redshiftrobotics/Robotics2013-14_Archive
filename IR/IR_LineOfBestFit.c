#pragma config(Sensor, S1,     IR,             sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "HitecnicInfaredLibrary.h"

/*This code is to read the IRSeekerV2 signal and beep when the seeker is pointing directly at the IRBeacon. Currently the code only outputs the y-intercept and slope for the Line of Best Fit (LOBF); read below for more specifics. This code needs to be calibrated before it works: read through the specifics and then consult the bottom of the header.

- Program Specifics
The IRSeekerV2 data is being filtered with a method called "Line of Best Fit" or "Least-Squares Method" which I followed from the following URL: http://hotmath.com/hotmath_help/topics/line-of-best-fit.html.

- Inputs
Each LOBF calculation uses 10 x-inputs and 10 y-inputs. Each X-input is a reading from the IR "acs3" stored in the array "irInput". Assuming the time interval between readings is constant when we constanly call the "HTIRS2readALLACStrencth" function, each corrosponding y-input is an arbirary number 1-10 to remove the equations reliance on actual time.

-Calculation Uses
Isaac, AJ, Dale, and I recognized a nice bell-curve shape when strenght over time from the IR "acs3" signal is graphed. Using the LOBF formula found on the aformentioned URL, we calculate slope. This slope, should approach a value of zero, if not be at zero, only at the top of the bell curve when the IRSeekerV2 is pointing at the IRBeacon. The calculated y-intercept can serve as a threshold for the IR signal however, notice it is dependant on the distance between the IRBeacon and IRSeekerV2


-IMPORTANT Calibrations before use
1) I just realized that I could have mixed up my X and Y variables. I looked at when we solve for the y-intercept and recognized that it would yield un-usable data because I chose my y-variables as arbitrary integers 1-10; shouldn't my y-variable representing time be on the x-axis? Time (or whatever represents it) should always go on the x-axis.
DOUBLE CHECK MY LOGIC PLEASE

2) Run a test to determine the range of the LOBF slope value when the IRSeekerV2 is pointing at the IRBeacon. If no useful data comes up, mess around with the number of readings in each sample (size of "irInput" "y-Input" and length of "For loop") -- if the readings are too close together the slope would be super small and meaningless.

3) Find a good standard strength y-intercept value that we can use as a threshold. If we have not reached a certain strenght, we could just be reading a small flat part on the Bell Curve Graph and not actually be at the top of the curve facing the IRBeacon. Or ditch the y-intercept threshold value altogether because it is dependant on the distance between the IRBeacon and the IRSeekerV2 and instead only read the "acs3" data when both "acs2" and "acs4" have gone to zero.
*/
int acS1, acS2, acS3, acS4, acS5 = 0;
int irInput = [0,0,0,0,0,0,0,0,0,0];
int yInput = [1,2,3,4,5,6,7,8,9,10];
int slopeTH = 0; //Slope Threshold
int y_intTH = 0; //Y_intercept Threshold
int sum_y = 55;
int sum_x = 0;
int sum_xSquared = 0;
int sum_xTimesy = 0;
int mean_xTimesy = 0;
int mean_sum_xSquared = 0;
int slopeLOBF = 0;
int y_intLOBF = 0;

task main()
{
	clearDebugStream();

	while(true)
	{
		int sum_x = 0;
		for (i, i<11 , i++)
			{
			HTIRS2readAllACStrength(IR, acS1, acS2, acS3, acS4, acS5);
			irInput[i] = acS3; //Fill our array with readings
			sum_x += irInput[i]; //As we fill our array, calculate the sum of each value in the array. (its easiest this way)
			sum_xSquared += irInput[i]^2; //bottom half of equation. Every input squared
			sum_xTimesy += irInput[i] * yInput[i];//top half of equation
			}
		mean_xTimesy = (sum_x * sum_y)/10; //top half of equation. 10 = The number of entries AKA sample size
		mean_sum_xSquared = (sum_x^2)/10; //bottom half of equation
		slopeLOBF = (sum_xTimesy-mean_xTimesy)/(sum_xSquared - mean_sum_xSquared) //calculate LOBF slope
		y_intLOBF = sum_y - (sum_x * slopeLOBF); //Calculate LOBF y-intercept
		while (y_intLOBF >= y_intTH) //So long as we are above our y-intercept threshold AKA know we are close to the top of the curve
			{
			if (slopeLOBF <= slopeTH|| slopeTH >=) //Wait untill our LOBF slope falls within its own calibrated threshold
				{
				//Make beeping noise perhaps turn left because we have determined the IRSeekerV2 to be facing the IRBeacon
				}
			}
		writeDebugStream("%i,", slopeLOBF);
		writeDebugStreamLine("%i,", y_intLOBF);
		sleep(50);
	}
}
