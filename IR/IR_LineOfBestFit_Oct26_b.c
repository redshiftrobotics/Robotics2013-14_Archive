#pragma config(Sensor, S1,     IR,             sensorI2CCustom)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#include "HitecnicInfaredLibrary.h"

/*This code is to read the IRSeekerV2 signal and beep when the seeker is pointing directly at the IRBeacon. Currently the code only outputs the y-intercept and slope for the Line of Best Fit (LOBF); read below for more specifics. This code needs to be calibrated before it works: read through the specifics and then consult the bottom of the header.

- Program Specifics
The IRSeekerV2 data is being filtered with a method called "Line of Best Fit" or "Least-Squares Method" which I followed from the following URL: http://hotmath.com/hotmath_help/topics/line-of-best-fit.html.

- Inputs
Each LOBF calculation uses 10 x-inputs and 10 y-inputs. Each X-input is a reading from the IR "acs3" stored in the array "irInput". Assuming the time interval between readings is constant when we constanly call the "HTIRS2readALLACStrencth" function, each corrosponding y-input is an arbirary number 1-10 to remove the equations reliance on actual time.

-Calculation Uses
Isaac, AJ, Dale, and I recognized a nice bell-curve shape when strenght over time from the IR "acs3" signal is graphed. Using the LOBF formula found on the aformentioned URL, we calculate slope. This slope, should approach a value of zero, if not be at zero, only at the top of the bell curve when the IRSeekerV2 is pointing at the IRBeacon. The calculated y-intercept can serve as a threshold for the IR signal however, notice it is dependant on the distance between the IRBeacon and IRSeekerV2
*/

int acS1, acS2, acS3, acS4, acS5 = 0;
int n = 20; //Change sample size

long sY = 0; //We are squaring summations -> KEEP THESE AS LONGS
long sX = 0;
long spX2p = 0;
long psXp2 = 0;
float mpsXp2 = 0;
long sXsY = 0;
float msXsY = 0;
long spXYp = 0;

float slopeLOBF = 0;

task main()
{
	clearDebugStream();

	while(true)
	{
		sY = 0;
		sX = 0;
		spXYp = 0;
		spX2p = 0;
		for (int X = 1; X<n+1 ; X++)
		{
			HTIRS2readAllACStrength(IR, acS1, acS2, acS3, acS4, acS5);
			sY += acS3;
			sX += X;
			spX2p += X*X;
			spXYp += (X * acS3) ;
			writeDebugStream("%i,", acS3);
			writeDebugStreamLine("0");
			Sleep(10);
		}
		psXp2 = (sX*sX);
		mpsXp2 = psXp2/n;
		sXsY = (sX*sY);
		msXsY = (sXsY)/n;
		slopeLOBF = (spXYp - msXsY)/(spX2p - mpsXp2);
		if (slopeLOBF< -(n/100))//the denominator can be the threshold turn point. Notice it is dependant on speed of robot and rotation of sensor.
		{
			PlayTone(1000,13);
		}
		writeDebugStream("0, ");
		writeDebugStream("slope:%f, ", slopeLOBF);
		writeDebugStream("sY:%i, ", sY);
		writeDebugStream("psXp2:%i, ", psXp2);
		writeDebugStream("mpsXp2:%f, ", mpsXp2);
		writeDebugStream("sXsY:%i, ", sXsY);
		writeDebugStream("msXsY:%f, ", msXsY);
		writeDebugStreamLine("spXYp:%i", spXYp);
		Sleep(50);
	}
}
